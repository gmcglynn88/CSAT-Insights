<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    /* [All your CSS styles remain exactly the same - no changes needed] */
  </style>
</head>
<body>
  <!-- [All your HTML structure remains exactly the same - no changes needed] -->

  <script>
    // ===== OAuth Configuration =====
    // [All your OAuth config remains the same]

    const state = {
      accessToken: null,
      users: [],
      teams: [],
      teamMembers: new Map(),
      surveys: []
    };

    // ===== Helper Functions =====
    // [All your helper functions remain the same until loadSurveys()]

    // ===== Main Survey Loading - UPDATED =====
    async function loadSurveys(){
      const fromDate = document.getElementById('fromDate').value;
      const toDate = document.getElementById('toDate').value;
      
      if(!fromDate || !toDate){
        msg('Please select both From and To dates.', 'error');
        return;
      }
      
      const start = new Date(fromDate + 'T00:00:00.000Z');
      const end = new Date(toDate + 'T23:59:59.999Z');
      const diffDays = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
      
      if (diffDays > 90) {
        msg('Date range cannot exceed 90 days.', 'error');
        return;
      }
      
      if (diffDays < 0) {
        msg('End date must be after start date.', 'error');
        return;
      }
      
      const agentIds = await computeSelectedAgentIds();
      
      const btn = document.getElementById('loadBtn'); 
      setLoading(btn, true); 
      msg('Loading survey data...', 'info');
      
      try {
        // STEP 1: Get conversations with accurate dates/times
        const conversationData = await fetchConversations(start, end);
        
        // STEP 2: Get detailed survey responses with actual question scores
        const surveyResponses = await fetchSurveyResponses(start, end, agentIds);
        
        // STEP 3: Combine the data
        state.surveys = await processSurveyData(conversationData, surveyResponses);
        
        renderSurveys();
        msg(`Loaded ${state.surveys.length} survey responses.`, 'success');
      } catch(e) { 
        console.error('Error loading surveys:', e); 
        msg('Failed to load surveys: ' + e.message, 'error'); 
      } finally { 
        setLoading(btn, false); 
      }
    }

    // ===== API 1: Conversations Details (ONLY interval) =====
    async function fetchConversations(start, end) {
      const url = `https://api.${config.REGION}/api/v2/analytics/conversations/details/query`;
      
      const body = {
        "interval": `${start.toISOString()}/${end.toISOString()}`,
        "order": "desc",
        "orderBy": "conversationStart",
        "paging": { "pageSize": 100, "pageNumber": 1 }
      };
      
      console.log('Fetching conversations:', JSON.stringify(body, null, 2));
      
      try {
        const data = await fetchJsonWithRetry(url, {
          method: 'POST',
          body: JSON.stringify(body)
        });
        
        console.log('Conversations response:', data);
        return data;
      } catch (error) {
        console.error('Error fetching conversations:', error);
        throw error;
      }
    }

    // ===== NEW: Fetch Detailed Survey Responses (not aggregates) =====
    async function fetchSurveyResponses(start, end, agentIds) {
      const url = `https://api.${config.REGION}/api/v2/analytics/surveys/responses/query`;
      
      const body = {
        "interval": `${start.toISOString()}/${end.toISOString()}`,
        "order": "desc",
        "orderBy": "conversationStart",
        "paging": { "pageSize": 100, "pageNumber": 1 },
        "segmentFilters": [
          {
            "type": "and",
            "predicates": [
              {
                "type": "dimension",
                "dimension": "mediaType",
                "operator": "matches",
                "value": "voice"
              }
            ]
          }
        ]
      };
      
      console.log('Fetching survey RESPONSES (not aggregates):', JSON.stringify(body, null, 2));
      
      try {
        const data = await fetchJsonWithRetry(url, {
          method: 'POST',
          body: JSON.stringify(body)
        });
        
        console.log('Survey RESPONSES data:', data);
        return data;
      } catch (error) {
        console.error('Error fetching survey responses:', error);
        // If this endpoint doesn't work, fall back to aggregates
        console.log('Falling back to aggregates API for question scores...');
        return await fetchSurveyAggregatesAsFallback(start, end, agentIds);
      }
    }

    // Fallback: Use aggregates API if responses endpoint fails
    async function fetchSurveyAggregatesAsFallback(start, end, agentIds) {
      const url = `https://api.${config.REGION}/api/v2/analytics/surveys/aggregates/query`;
      
      const body = {
        "interval": `${start.toISOString()}/${end.toISOString()}`,
        "granularity": "P1D",
        "groupBy": ["conversationId", "userId", "surveyFormName"],
        "metrics": ["oSurveyTotalScore", "nSurveyResponses"],
        "flattenMultivaluedDimensions": false
      };
      
      if (agentIds && agentIds.length > 0) {
        body.filter = {
          "type": "or",
          "predicates": agentIds.map(agentId => ({
            "type": "dimension",
            "dimension": "userId",
            "operator": "matches",
            "value": agentId
          }))
        };
      }
      
      console.log('Using aggregates fallback:', JSON.stringify(body, null, 2));
      
      const data = await fetchJsonWithRetry(url, {
        method: 'POST',
        body: JSON.stringify(body)
      });
      
      return data;
    }

    // ===== Process Survey Data =====
    async function processSurveyData(conversationData, surveyData) {
      const surveys = [];
      
      // Create a map of conversationId -> conversation details
      const conversationMap = new Map();
      
      if (conversationData && conversationData.conversations) {
        conversationData.conversations.forEach(conversation => {
          const convId = conversation.conversationId;
          if (convId) {
            conversationMap.set(convId, {
              conversationId: convId,
              conversationStart: conversation.conversationStart,
              conversationEnd: conversation.conversationEnd,
              duration: conversation.conversationStart && conversation.conversationEnd ? 
                Math.round((new Date(conversation.conversationEnd) - new Date(conversation.conversationStart)) / 1000) : 0,
              participants: conversation.participants || []
            });
          }
        });
      }
      
      console.log(`Found ${conversationMap.size} conversations`);
      
      // Process survey responses data
      // Structure depends on which API was used
      
      if (surveyData && surveyData.results) {
        // This is from the responses API - contains actual question scores
        console.log('Processing survey RESPONSES data');
        
        for (const result of surveyData.results) {
          const convId = result.conversationId;
          const userId = result.userId;
          
          if (!convId || !userId) {
            console.log('Skipping: missing conversationId or userId');
            continue;
          }
          
          // Get conversation details
          const conversation = conversationMap.get(convId);
          
          let conversationDate = new Date();
          let duration = 0;
          
          if (conversation) {
            if (conversation.conversationStart) {
              conversationDate = new Date(conversation.conversationStart);
            }
            duration = conversation.duration || 0;
          }
          
          // Find agent name
          const agent = state.users.find(u => u.id === userId);
          const agentName = agent ? agent.name : 'Unknown Agent';
          
          // Extract survey data from the response
          const surveyFormName = result.surveyFormName || 'Unknown Survey';
          const totalScore = result.totalScore || 0;
          
          // Extract ACTUAL question scores from survey responses
          const questionScores = extractQuestionScoresFromResponse(result);
          
          surveys.push({
            conversationId: convId,
            userId: userId,
            agentName: agentName,
            surveyFormName: surveyFormName,
            conversationDate: conversationDate,
            conversationStart: conversation?.conversationStart || null,
            conversationEnd: conversation?.conversationEnd || null,
            duration: duration,
            totalScore: totalScore,
            questionScores: questionScores,
            hasAccurateTime: !!conversation?.conversationStart,
            isEstimatedScores: false, // Using ACTUAL scores from responses API
            source: 'responses'
          });
        }
      } else if (surveyData && surveyData.entities) {
        // This is from the aggregates fallback API - only has total scores
        console.log('Processing survey AGGREGATES data (fallback)');
        
        for (const entity of surveyData.entities) {
          if (entity.group && entity.group.conversationId) {
            const convId = entity.group.conversationId;
            const userId = entity.group.userId;
            const formName = entity.group.surveyFormName;
            
            if (!convId || !userId) continue;
            
            const conversation = conversationMap.get(convId);
            
            let conversationDate = new Date();
            let duration = 0;
            
            if (conversation) {
              if (conversation.conversationStart) {
                conversationDate = new Date(conversation.conversationStart);
              }
              duration = conversation.duration || 0;
            }
            
            const agent = state.users.find(u => u.id === userId);
            const agentName = agent ? agent.name : 'Unknown Agent';
            
            // Get total score from aggregates
            let totalScore = 0;
            if (entity.data && entity.data[0] && entity.data[0].metrics) {
              entity.data[0].metrics.forEach(metric => {
                if (metric.metric === 'oSurveyTotalScore' && metric.stats) {
                  if (metric.stats.average !== undefined) {
                    totalScore = metric.stats.average;
                  }
                }
              });
            }
            
            surveys.push({
              conversationId: convId,
              userId: userId,
              agentName: agentName,
              surveyFormName: formName || 'Unknown Survey',
              conversationDate: conversationDate,
              conversationStart: conversation?.conversationStart || null,
              conversationEnd: conversation?.conversationEnd || null,
              duration: duration,
              totalScore: totalScore,
              questionScores: [], // No question scores from aggregates
              hasAccurateTime: !!conversation?.conversationStart,
              isEstimatedScores: true,
              source: 'aggregates'
            });
          }
        }
      }
      
      console.log(`Processed ${surveys.length} surveys`);
      return surveys;
    }

    // ===== Extract Actual Question Scores from Survey Response =====
    function extractQuestionScoresFromResponse(surveyResponse) {
      const questionScores = [];
      
      // Try different possible response structures
      
      // Structure 1: surveyQuestionGroupScore array
      if (surveyResponse.surveyQuestionGroupScore && Array.isArray(surveyResponse.surveyQuestionGroupScore)) {
        surveyResponse.surveyQuestionGroupScore.forEach(group => {
          if (group.surveyQuestionScore && Array.isArray(group.surveyQuestionScore)) {
            group.surveyQuestionScore.forEach(qScore => {
              if (qScore.score !== undefined && qScore.maxScore !== undefined) {
                questionScores.push({
                  score: qScore.score,
                  maxScore: qScore.maxScore,
                  text: qScore.questionText || 'Survey Question',
                  answerText: qScore.answerText || '',
                  percentage: qScore.maxScore > 0 ? (qScore.score / qScore.maxScore) * 100 : 0
                });
              }
            });
          }
        });
      }
      
      // Structure 2: questionResponses object
      if (surveyResponse.questionResponses && typeof surveyResponse.questionResponses === 'object') {
        Object.entries(surveyResponse.questionResponses).forEach(([questionId, response]) => {
          if (response.score !== undefined && response.maxScore !== undefined) {
            questionScores.push({
              score: response.score,
              maxScore: response.maxScore,
              text: response.questionText || `Question ${questionId}`,
              answerText: response.answerText || '',
              percentage: response.maxScore > 0 ? (response.score / response.maxScore) * 100 : 0
            });
          }
        });
      }
      
      // Structure 3: answers object
      if (surveyResponse.answers && surveyResponse.answers.formAnswers) {
        Object.entries(surveyResponse.answers.formAnswers).forEach(([questionId, answer]) => {
          if (answer.score !== undefined && answer.maxScore !== undefined) {
            questionScores.push({
              score: answer.score,
              maxScore: answer.maxScore,
              text: answer.questionText || `Question ${questionId}`,
              answerText: answer.textResponse || '',
              percentage: answer.maxScore > 0 ? (answer.score / answer.maxScore) * 100 : 0
            });
          }
        });
      }
      
      console.log(`Extracted ${questionScores.length} question scores from survey response`);
      return questionScores;
    }

    // ===== Render Surveys - UPDATED =====
    function renderSurveys(){
      const container = document.getElementById('surveysContainer');
      
      if(!state.surveys || state.surveys.length === 0){
        container.innerHTML = `
          <div class="stat-card">
            <div class="value">0</div>
            <div class="label">Survey Responses Found</div>
          </div>
          <div class="muted">No survey responses found for the selected criteria.</div>
        `;
        return;
      }
      
      // Calculate statistics
      const totalSurveys = state.surveys.length;
      const totalScore = state.surveys.reduce((sum, s) => sum + (s.totalScore || 0), 0);
      const avgScore = totalSurveys > 0 ? totalScore / totalSurveys : 0;
      
      // Check data source
      const usingResponsesAPI = state.surveys.some(s => s.source === 'responses');
      const usingAggregatesAPI = state.surveys.some(s => s.source === 'aggregates');
      
      let warningNote = '';
      if (usingResponsesAPI) {
        warningNote = '<div class="success-message" style="margin-bottom: 15px;"><strong>✓ Using Survey Responses API:</strong> Showing actual question scores from survey responses.</div>';
      } else if (usingAggregatesAPI) {
        warningNote = '<div class="warning-note"><strong>Note:</strong> Using Survey Aggregates API - only total scores available. Question scores not available from this API.</div>';
      }
      
      let html = `
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 20px;">
          <div class="stat-card">
            <div class="value">${totalSurveys}</div>
            <div class="label">Survey Responses</div>
          </div>
          <div class="stat-card">
            <div class="value">${avgScore.toFixed(1)}%</div>
            <div class="label">Average Score</div>
          </div>
        </div>
        
        ${warningNote}
        
        <div class="table-container">
          <table>
            <thead>
              <tr>
                <th>Agent</th>
                <th>Date & Time</th>
                <th>Duration</th>
                <th>Survey Form</th>
                <th>Score</th>
                <th>Details</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      let rowIndex = 0;
      
      // Sort surveys by date (newest first)
      const sortedSurveys = [...state.surveys].sort((a, b) => b.conversationDate - a.conversationDate);
      
      sortedSurveys.forEach((survey) => {
        const score = survey.totalScore || 0;
        const rating = getRatingLabel(score);
        const roundedScore = Math.min(5, Math.max(1, Math.round(score / 20)));
        const dateTime = formatDateTime(survey.conversationDate);
        const duration = formatDuration(survey.duration);
        
        html += `
          <tr class="expandable-row" onclick="toggleSurveyRow(${rowIndex})">
            <td><strong>${survey.agentName}</strong></td>
            <td>${dateTime}</td>
            <td>${duration ? `<span class="duration-badge">${duration}</span>` : 'N/A'}</td>
            <td>${survey.surveyFormName || 'Unknown'}</td>
            <td>
              <span class="rating-indicator rating-${roundedScore}"></span>
              <span class="badge ${rating.badge}">${score.toFixed(1)}% - ${rating.label}</span>
            </td>
            <td><span class="expand-icon">▶</span> Click to expand</td>
          </tr>
          <tr id="survey-row-${rowIndex}" class="expandable-content">
            <td colspan="6">
              <div class="survey-details">
                <div><strong>Agent:</strong> ${survey.agentName}</div>
                <div><strong>Date & Time:</strong> ${dateTime}</div>
                <div><strong>Duration:</strong> ${duration || 'N/A'}</div>
                <div><strong>Survey Form:</strong> ${survey.surveyFormName || 'Unknown'}</div>
                <div><strong>Total Score:</strong> ${score.toFixed(1)}%</div>
                <div><strong>Conversation ID:</strong> ${survey.conversationId}</div>
                <div><strong>Data Source:</strong> ${survey.source === 'responses' ? 'Survey Responses API (actual scores)' : 'Survey Aggregates API (total only)'}</div>
                
                <h5 style="margin-top: 15px;">Question Responses:</h5>
                
                ${survey.questionScores && survey.questionScores.length > 0 ? 
                  survey.questionScores.map((qScore, qIndex) => {
                    // Map questions to standard groups
                    let groupName = 'Survey Questions';
                    const questionText = qScore.text || '';
                    
                    if (questionText.toLowerCase().includes('easy') || questionText.toLowerCase().includes('handling')) {
                      groupName = 'Enquiry Management';
                    } else if (questionText.toLowerCase().includes('satisfied') || questionText.toLowerCase().includes('advisor')) {
                      groupName = 'Advisor Experience';
                    } else if (questionText.toLowerCase().includes('recommend') || questionText.toLowerCase().includes('likely')) {
                      groupName = 'Overall Experience';
                    }
                    
                    const scoreClass = qScore.maxScore === 10 ? 
                      `score-${Math.min(10, Math.max(1, qScore.score))}` : 
                      `score-${Math.min(5, Math.max(1, qScore.score))}`;
                    
                    return `
                      <div class="question-group">
                        <div class="question-group-title">${groupName}</div>
                        <div class="survey-question">
                          <div class="question-text">${questionText}</div>
                          ${qScore.answerText ? `<div class="feedback-text"><strong>Answer:</strong> ${qScore.answerText}</div>` : ''}
                          <div>
                            <strong>Score:</strong> 
                            <span class="score-badge ${scoreClass}">
                              ${qScore.score}/${qScore.maxScore}
                            </span>
                            <span class="score-display">
                              (${qScore.percentage.toFixed(0)}%)
                            </span>
                          </div>
                        </div>
                      </div>
                    `;
                  }).join('') + `
                  <div class="question-group">
                    <div class="question-group-title">Any Feedback</div>
                    <div class="survey-question">
                      <div class="question-text">Is there anything else we could have done to improve your service today?</div>
                      <div><em>Free text response (no score)</em></div>
                      <div class="muted" style="margin-top: 5px;">Check for feedback in answer text above.</div>
                    </div>
                  </div>
                  `
                  : 
                  `<div class="muted">
                    ${survey.source === 'responses' ? 
                      'No question scores found in response data.' : 
                      'Question scores not available via Aggregates API. Use Genesys UI for detailed results.'}
                  </div>`
                }
              </div>
            </td>
          </tr>
        `;
        
        rowIndex++;
      });
      
      html += `
            </tbody>
          </table>
        </div>
        <div class="muted" style="margin-top:10px">
          Showing ${sortedSurveys.length} survey responses
          ${usingResponsesAPI ? '(with actual question scores)' : '(total scores only)'}
        </div>
      `;
      
      container.innerHTML = html;
    }

    // ===== Global Functions for HTML =====
    // [These remain the same]
  </script>
</body>
</html>
